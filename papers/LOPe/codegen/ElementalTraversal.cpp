#include <rose.h>
#include "ElementalTraversal.hpp"
#include "FortranAnalysis.hpp"

ElementalTraversal::ElementalTraversal(int argc, char * argv[], const char * filename)
   : FortranTraversal(filename)
{
   line = 0;
   num_dims = 1;
   num_arrays = 0;
   array_list = new char * [1];
   array_list[0] = NULL;

   // look for -ofp:dims argument
   //
   for (int i = 0; i < argc; i++) {
      char * str = argv[i];
      if (strncmp(str, "-ofp:dims", 9) != 0) continue;
      num_dims = atoi(&str[9]);
      printf("found num_dims==%d str==%s\n", num_dims, str);
      break;
   }

   open(filename);
}

void ElementalTraversal::open(const char * filename)
{
   this->fp = fopen(filename, "w");
   if (fp == NULL) {
      printf("ElementalTraversal:: ERROR in opening file %s\n", filename);
   }
   ROSE_ASSERT(fp != NULL);

   fprintf(fp, "/*\n");
   fprintf(fp, " * This kernel is automatically generated by Open Fortran Project tools.\n");
   fprintf(fp, " */\n");
   fprintf(fp, "\n");

   fprintf(fp, "static inline int get_global_idx_1d()\n");
   fprintf(fp, "{\n");
   fprintf(fp, "   return get_global_id(0);\n");
   fprintf(fp, "}\n\n");

   fprintf(fp, "static inline int get_global_idx_2d()\n");
   fprintf(fp, "{\n");
   fprintf(fp, "   return get_global_id(0) + get_global_size(0)*get_global_id(1);\n");
   fprintf(fp, "}\n");
}

void ElementalTraversal::visit(SgNode * node)
{
   switch (node->variantT())
   {
      case V_SgFunctionDefinition  : visit( (SgFunctionDefinition  *) node);  break;
   }
}

#ifdef OBSOLETE
void ElementalTraversal::visit(SgFunctionDeclaration * func_decl)
{
   char comma[2] = {0,0};

   std::string func_name = func_decl->get_name();
   std::string filename = func_name + ".f90";
   filename = filename.substr(4,filename.size()-1);
   filename[0] = tolower(filename[0]);

   open(filename.c_str());

   fprintf(fp, "\n");
   fprintf(fp, "subroutine %s_wrapper(", func_name.c_str());

   // parameter list
   //

   SgInitializedNamePtrList & names = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator it = names.begin();

   while (it != names.end()) {
      const char * name = (*it++)->get_name().str();
      fprintf(fp, "%s%s", comma, name);
      comma[0] = ',';
   }

   fprintf(fp, ")\n");
   fprintf(fp, "  implicit none\n");

   // variable decls
   //
   SgFunctionDefinition * func_def = func_decl->get_definition();

   visit(func_def);

   // end subroutine stmt
   //
   fprintf(fp, "end subroutine %s_wrapper\n", func_name.c_str());

   fclose(fp);
   fp = NULL;
}
#endif

void ElementalTraversal::visit(SgFunctionDefinition * func_def)
{
   char comma[2] = {0,0};

   SgFunctionDeclaration * func_decl = func_def->get_declaration();
   std::string func_name = func_decl->get_name();

   SgBasicBlock * block = func_def->get_body();
   SgStatementPtrList & stmts = block->get_statements();

   fprintf(fp, "\n");
   fprintf(fp, "__kernel void %s (", func_name.c_str());

   // parameter list
   //

   SgInitializedNamePtrList & names = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator p = names.begin();

   while (p != names.end()) {
      fprintf(fp, "%s\n", comma);
      unparseFuncParam(*p++, func_def);
      comma[0] = ',';
   }

   // add return argument to parameter list
   unparseFuncParamReturn(func_decl, comma);

   // add array descriptors to parameter list
   unparseArrayDescs(func_decl);

   fprintf(fp, " )\n");
   fprintf(fp, "{\n");

   // declare local variables
   //
   SgStatementPtrList::iterator stmt = stmts.begin();
   while (stmt != stmts.end()) {
      if (isSgVariableDeclaration(*stmt)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*stmt);
         unparseVarDecl(var_decl, func_def);
      }
      stmt++;
   }
   fprintf(fp, "\n");

   // declare and define index variables
   //
   unparseIndexVars(func_decl);
   fprintf(fp, "\n");

   stmt = stmts.begin();
   while (stmt != stmts.end()) {
      if (isSgStatement(*stmt)) {
         unparseStmt(isSgStatement(*stmt));
      }
      stmt++;
   }

   fprintf(fp, "}\n");
}

void ElementalTraversal::unparseStmt(SgStatement * stmt)
{
   Sg_File_Info * info = stmt->get_startOfConstruct();
   if (isSgDeclarationStatement(stmt) != NULL) {
   }
   if (isSgExprStatement(stmt) != NULL) {
      if (line == 0) {
         line = info->get_line();
      }
      while (line++ < info->get_line()) {
         fprintf(fp, "\n");
      }
      // assume this is an assignment statement and insert appropriate whitespace
      fprintf(fp, "   ");
      unparseExpr(isSgExprStatement(stmt)->get_expression());
      fprintf(fp, ";\n");
   }
}

void ElementalTraversal::unparseExpr(SgExpression * expr)
{
   if (isSgBinaryOp(expr))              unparseBinaryOp(isSgBinaryOp(expr));
   else if (isSgUnaryOp(expr))          unparseUnaryOp(isSgUnaryOp(expr));
   else if (isSgVarRefExp(expr))        unparseVarRefExpr(isSgVarRefExp(expr));
   else if (isSgFunctionCallExp(expr))  unparseFuncCallExpr(isSgFunctionCallExp(expr));
   else if (isSgValueExp(expr)) {
      SgValueExp * val = isSgValueExp(expr);
      if (isSgFloatVal(val)) {
         fprintf(fp, "%s", isSgFloatVal(val)->get_valueString().c_str());
      }
   }
   else if (isSgFunctionRefExp(expr)) {
      SgFunctionRefExp * func_ref = isSgFunctionRefExp(expr);
      fprintf(fp, "%s", func_ref->get_symbol()->get_name().str());
   }
   else {
      fprintf(fp, "%s", "UNKNOWN EXPR");
   }

}

void ElementalTraversal::unparseFuncCallExpr(SgFunctionCallExp * func_call)
{
   SgExpressionPtrList & list = func_call->get_args()->get_expressions();
   SgExpressionPtrList::iterator arg = list.begin();

   unparseExpr(func_call->get_function());
   fprintf(fp, "(");

   while(arg != list.end()) {
      unparseExpr(*arg++);
   }

   fprintf(fp, ")");
}

void ElementalTraversal::unparseBinaryOp(SgBinaryOp * op)
{
   SgExpression * lhs = op->get_lhs_operand();
   SgExpression * rhs = op->get_rhs_operand();

   unparseExpr(lhs);
   if (isSgAssignOp(op)) {
      fprintf(fp, " = ");
   }
   else if (isSgAddOp(op)) {
      fprintf(fp, " + ");
   }
   else if (isSgSubtractOp(op)) {
      fprintf(fp, " - ");
   }
   else if (isSgMultiplyOp(op)) {
      fprintf(fp, "*");
   }
   else if (isSgDivideOp(op)) {
      fprintf(fp, "/");
   }
   else if (isSgDotExp(op)) {
      fprintf(fp, "->");
   }
   unparseExpr(rhs);
}

void ElementalTraversal::unparseUnaryOp(SgUnaryOp * op)
{
   SgExpression * operand = op->get_operand();
   if (isSgMinusOp(op)) {
      fprintf(fp, "-");
   }
   else if (isSgUnaryAddOp(op)) {
      fprintf(fp, "+");
   }
   unparseExpr(operand);
}

void ElementalTraversal::unparseVarRefExpr(SgVarRefExp * var)
{
   SgSymbol * sym = var->get_symbol();
   const char * index = FortranAnalysis::getAttributeValue(sym, "index_attr");
   fprintf(fp, "%s", sym->get_name().getString().c_str());
   if (index != NULL) fprintf(fp, "[%s]", index);
}

void ElementalTraversal::unparseVarDecl(SgVariableDeclaration * var_decl, SgFunctionDefinition * func_def)
{
   bool declare_ic = false;
   char comma[2] = {0,0};
   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   // make sure we aren't in a type definition
   if (isSgClassDefinition(var_decl->get_parent())) return;

   // make sure there are local (non-dummy) arguments
   if (! FortranAnalysis::hasLocalVariable(var_decl, func_def)) return;

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator var = vars.begin();

   // find the base type of the declaration statement
   //
   SgType * type = (*var)->get_typeptr();
   fprintf(fp, "   ");
   unparseType(type);

   //   if (isSgArrayType(type)) {
   //      type = isSgArrayType(type)->get_base_type();
   //   }

#ifdef NOTME
   if (isSgTypeFloat(type)) {
      unparseFloatVarDeclStmt(var_decl, true);
      return;
   }
   else if (isSgTypeInt(type)) {
      unparseIntVarDeclStmt(var_decl, true);
      return;
   }
   else {
      fprintf(fp, "  TYPE(UNKNOWN)==%s", type->class_name().c_str());
   }
#endif

   var = vars.begin();
   while (var != vars.end()) {
      std::string name = (*var++)->get_name();
      SgSymbol * sym = func_def->lookup_symbol(name);
      if (FortranAnalysis::isDummyVariable(sym)) continue;

      fprintf(fp, "%s %s", comma, name.c_str());
      comma[0] = ',';
   }
   fprintf(fp, ";\n");
}

/**
 * Define local "C" variables before calling the MPI function.
 */
void ElementalTraversal::unparseVarDef(SgVariableDeclaration * var_decl, bool local_decl)
{
   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   // make sure we aren't in a type definition, e.g., TYPE :: MPI_Comm
   if (isSgClassDefinition(var_decl->get_parent())) return;

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator ivars = vars.begin();

   SgType * type = (*ivars)->get_typeptr();
   while (ivars != vars.end()) {
      const char * var_name = (*ivars++)->get_name().str();
      if (isChoiceBuffer(var_decl)) continue;
      if (isSgNamedType(type)) {
         // e.g.:  TYPE(MPI_Comm)
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            std::string type_name = isSgNamedType(type)->get_name();
            // Yuk, MPI_Type_f2c should be MPI_Datatype_f2c
            if (type_name == "MPI_Datatype") {
               type_name = "MPI_Type";
            }
            fprintf(fp, "  %s_c = %s_f2c_c(%s%%mpi_val)\n", var_name, type_name.c_str(), var_name);
         }
      }
      else if (isSgTypeInt(type)) {
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = %s\n", var_name, var_name);
         }
      }
      else if (isSgTypeBool(type)) {
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = MERGE(1, 0, %s)\n", var_name, var_name);
         }
      }
      else if (isSgArrayType(type)) {
         if (isArrayOfRequests(var_decl)) {
            fprintf(fp, "  do ic = 1, count\n");
            fprintf(fp, "    array_of_requests_c(ic) = MPI_Request_f2c_c(array_of_requests(ic)%%mpi_val)\n");
            fprintf(fp, "  end do\n");
         }
         else if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = IMPLEMENT ARRAY TYPE for var def\n", var_name, var_name);
         }
      }
      else {
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = IMPLEMENT ME class==%s\n", var_name, type->class_name().c_str());
         }
      }
   }
}

/**
 * Define out parameters based on the results of the MPI function call
 */
void ElementalTraversal::unparseParamDef(SgVariableDeclaration * var_decl)
{
   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   // make sure we aren't in a type definition, e.g., TYPE :: MPI_Comm
   if (isSgClassDefinition(var_decl->get_parent())) return;

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator ivars = vars.begin();

   SgType * type = (*ivars)->get_typeptr();
   for (ivars = vars.begin(); ivars != vars.end(); ivars++) {
      const char * var_name  = (*ivars)->get_name().str();
      if (isSgTypeInt(type)) {
         if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            fprintf(fp, "    %s = %s_c\n", var_name, var_name);
         }
      }
      else if (isSgNamedType(type)) {
         // e.g.:  TYPE(MPI_Comm)
         if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            std::string type_name = isSgNamedType(type)->get_name();
            // Yuk, MPI_Type_f2c should be MPI_Datatype_f2c
            if (type_name == "MPI_Datatype") {
               type_name = "MPI_Type";
            }
            fprintf(fp, "    %s%%mpi_val = %s_c2f_c(%s_c)\n", var_name, type_name.c_str(), var_name);
         }
      }
      else if (isSgTypeBool(type)) {
         if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            fprintf(fp, "    %s = MERGE(true, false, %s_c/=0)\n", var_name, var_name);
         }
      }
      else {
         if (isArrayOfRequests(var_decl)) {
            fprintf(fp, "    do ic = 1, count\n");
            fprintf(fp, "      array_of_requests(ic)%%mpi_val = MPI_Request_c2f_c(array_of_requests_c(ic))\n");
            fprintf(fp, "    end do\n");
         }
         else if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            fprintf(fp, "    %s_c = IMPLEMENT ME class==%s\n", var_name, type->class_name().c_str());
         }
      }
   }
}

void ElementalTraversal::unparseFunctionCall(SgFunctionDefinition * func_def)
{
   char comma[2] = {0,0};
   SgInitializedName * err_var = NULL;

   SgBasicBlock * block = func_def->get_body();
   SgStatementPtrList & stmts = block->get_statements();
   SgFunctionDeclaration * func_decl = func_def->get_declaration();

   // need parameter list to order the local variables and make the function call
   SgInitializedNamePtrList & params = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator iparams = params.begin();

   SgStatementPtrList::iterator istmts;
   for (istmts = stmts.begin(); istmts != stmts.end(); istmts++) {
      if (isSgVariableDeclaration(*istmts)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*istmts);
         if (isErrorReturn(var_decl)) {
            SgInitializedNamePtrList & vars = var_decl->get_variables();
            SgInitializedNamePtrList::iterator ivars = vars.begin();
            if ((*ivars)->get_name() == "ierror") {
               err_var = (*ivars);
               break;
            }
         }
      }
   }
   ROSE_ASSERT(err_var != NULL);

   const char * func_name = func_decl->get_name().str();
   fprintf(fp, "  %s_c = %s_c(", err_var->get_name().str(), func_name);

   // Unparse variables to function call.  The outer loop is necessary
   // to order the order the local variables to make the function call.

   for (iparams = params.begin(); iparams != params.end(); iparams++) {
      std::string param_name = (*iparams)->get_name();
      istmts = stmts.begin();
      for (istmts = stmts.begin(); istmts != stmts.end(); istmts++) {
         if (isSgVariableDeclaration(*istmts)) {
            SgVariableDeclaration * var_decl = isSgVariableDeclaration(*istmts);
            SgInitializedNamePtrList & vars = var_decl->get_variables();
            SgInitializedNamePtrList::iterator ivars = vars.begin();
            for (ivars = vars.begin(); ivars != vars.end(); ivars++) {
               SgType * type = (*ivars)->get_typeptr();
               if (param_name != (*ivars)->get_name().getString()) continue;
               if (isChoiceBuffer(var_decl)) {
                  fprintf(fp, "%sC_LOC(%s)", comma, (*ivars)->get_name().str());
                  comma[0] = ',';
               }
               else if (isSgNamedType(type) && (isSgNamedType(type)->get_name() == "MPI_Status")) {
                  // use Fortran variable direction, no C equivalent
                  fprintf(fp, "%s%s", comma, (*ivars)->get_name().str());
                  comma[0] = ',';
               }
               else if (!isErrorReturn(var_decl)) {
                  fprintf(fp, "%s%s_c", comma, (*ivars)->get_name().str());
                  comma[0] = ',';
               }
            }
         }
      }
   }
   fprintf(fp, ")\n\n");
}

void ElementalTraversal::unparseFuncParam(SgInitializedName * iname, SgFunctionDefinition * func_def)
{
   bool isArrayType = false;

   SgSymbol * sym = func_def->lookup_symbol(iname->get_name());
   AstAttribute * attr = sym->getAttribute("elemental_attr");
   if (attr != NULL) {
      isArrayType = (attr->toString() == "ELEMENTAL_ARRAY");
   }

   SgType * type = iname->get_typeptr();

   fprintf(fp, "    ");
   if (isArrayType || isSgNamedType(type)) fprintf(fp, "__global ");

   attr = sym->getAttribute("generic_type_attr");
   if (attr != NULL) {
      fprintf(fp, "%s",attr->toString().c_str());
   }
   else {
      unparseType(type);
   }
   fprintf(fp, " ");

   if (isArrayType || isSgNamedType(type)) {
      fprintf(fp, "* ");
   }

   std::string name = iname->get_name();
   fprintf(fp, "%s", name.c_str());
}

/**
 * Unparse the function return parameter
 */
void ElementalTraversal::
     unparseFuncParamReturn(SgFunctionDeclaration * func_decl, const char * comma)
{
   bool isArrayType = false;

   SgFunctionDefinition * func_def = func_decl->get_definition();
#ifdef FIXME
   SgSymbol * sym = func_def->lookup_symbol(func_def->get_name());
   AstAttribute * attr = sym->getAttribute("elemental_attr");

   if (attr != NULL) {
      isArrayType = (attr->toString() == "ELEMENTAL_ARRAY");
   }
   //DELETE-ME bool isArrayType = isElementalArrayType(func_decl);
#endif

   SgType * type = func_decl->get_type()->get_return_type();
   if (isSgTypeVoid(type)) return;

   fprintf(fp, "%s\n", comma);
   if (isArrayType) {
      fprintf(fp, "    __global ");
   }
   unparseType(type);
   fprintf(fp, " ");

   if (isArrayType) {
      fprintf(fp, "* ");
   }
   fprintf(fp, "%s_rtn", func_decl->get_name().str());
}

/**
 * Unparse the list of scalar variables in a variable declaration statement.
 */
void ElementalTraversal::
     unparseVarDeclListForScalars(SgVariableDeclaration * var_decl, bool isLocal)
{
   char comma[2] = {0,0};

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   while (it != vars.end()) {
      SgInitializedName * sginame = (*it++);
      SgType * type = sginame->get_typeptr();

      if (!isSgArrayType(type)) {
         std::string name = sginame->get_name();
         if (isLocal) name += "_c";
         fprintf(fp, "%s %s", comma, name.c_str());
         comma[0] = ',';
      }
   }
}

/**
 * Unparse the list of array variables in a variable declaration statement.
 */
void ElementalTraversal
     ::unparseVarDeclListForArrays(SgVariableDeclaration * var_decl, bool isLocal)
{
   char comma[2] = {0,0};

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   while (it != vars.end()) {
      SgInitializedName * sginame = (*it++);
      SgType * type = sginame->get_typeptr();

      if (isSgArrayType(type)) {
         std::string name = sginame->get_name();
         if (isLocal) name += "_c";
         fprintf(fp, "%s %s(*)", comma, name.c_str());
         comma[0] = ',';
      }
   }
}

/**
 * Unparse a variable declaration statement for integer variables.
 */
void ElementalTraversal::unparseIntVarDeclStmt(SgVariableDeclaration * var_decl, bool local_decl)
{
   bool hasArrayType = false;
   bool hasScalarType = false;

   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   SgType * base_type = (*it)->get_typeptr();
   if (isSgArrayType(base_type)) {
      base_type = isSgArrayType(base_type)->get_base_type();
   }

   // separate scalars and arrays because arrays aren't passed by value
   while (it != vars.end()) {
      SgType * type = (*it++)->get_typeptr();
      if (isSgArrayType(type)) hasArrayType = true;
      else                     hasScalarType = true;
   }

   if (hasScalarType) {
      fprintf(fp, "  integer");
      if (local_decl) fprintf(fp, "(C_INT)");
      if (!local_decl) unparseOptionalModifier(typemod);
      //      if (!local_decl) unparseValueModifier(typemod);
      if (!local_decl) unparseIntentModifier(typemod);
      fprintf(fp, " ::");
      unparseVarDeclListForScalars(var_decl, local_decl);
      fprintf(fp, "\n");
   }

   if (hasArrayType) {
      fprintf(fp, "  integer");
      if (local_decl) fprintf(fp, "(C_INT)");
      if (!local_decl) unparseOptionalModifier(typemod);
      if (!local_decl) unparseIntentModifier(typemod);
      fprintf(fp, " ::");
      unparseVarDeclListForArrays(var_decl, local_decl);
      fprintf(fp, "\n");
   }
}

/**
 * Unparse a variable declaration statement for float variables.
 */
void ElementalTraversal::unparseFloatVarDeclStmt(SgVariableDeclaration * var_decl, bool local_decl)
{
   bool hasArrayType = false;
   bool hasScalarType = false;

   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   SgType * base_type = (*it)->get_typeptr();
   if (isSgArrayType(base_type)) {
      base_type = isSgArrayType(base_type)->get_base_type();
   }

   // separate scalars and arrays because arrays aren't passed by value
   while (it != vars.end()) {
      SgType * type = (*it++)->get_typeptr();
      if (isSgArrayType(type)) hasArrayType = true;
      else                     hasScalarType = true;
   }

   if (hasScalarType) {
      fprintf(fp, "    __global float *");
      unparseVarDeclListForScalars(var_decl, local_decl);
      fprintf(fp, "\n");
   }

   if (hasArrayType) {
      fprintf(fp, "  ERROR:unparseFloatVarDeclStmt: arguments to elemental must be scalar\n");
   }
}

void ElementalTraversal::unparseType(SgType * type)
{
   if (isSgTypeFloat(type)) {
      fprintf(fp, "float");
   }
   else if (isSgTypeInt(type)) {
      fprintf(fp, "int");
   }
   else if (isSgNamedType(type)) {
      fprintf(fp, "%s", isSgNamedType(type)->get_name().str());
   }
   else {
      fprintf(fp, "UNKNOWN TYPE");
   }
}

void ElementalTraversal::unparseArrayDescs(SgFunctionDeclaration * func_decl)
{
   SgFunctionDefinition * func_def = func_decl->get_definition();
   SgInitializedNamePtrList & names = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator it = names.begin();

   bool first = true;

   while (it != names.end()) {
      SgName sgname = (*it++)->get_name();
      const char * cname = sgname.getString().c_str();
      SgSymbol * sym = func_def->lookup_symbol(sgname);
      AstAttribute * attr = sym->getAttribute("descriptor_attr");
      if (attr != NULL) {
         if (attr->toString() == "HAS_DESCRIPTOR") {
            if (first) {
               fprintf(fp, ",\n    desc_%s", cname);
            }
            else fprintf(fp, ", desc_%s", cname);
         }
      }
   }
}

void ElementalTraversal::unparseIndexVars(SgFunctionDeclaration * func_decl)
{
   if (num_dims == 1) {
      fprintf(fp, "   int idx = get_global_idx_1d();\n");
   }
   else if (num_dims == 2) {
      fprintf(fp, "   int idx = get_global_idx_2d();\n");
   }

   SgFunctionDefinition * func_def = func_decl->get_definition();
   SgInitializedNamePtrList & names = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator it = names.begin();

   while (it != names.end()) {
      //      SgName sgname = (*it++)->get_name();
      SgSymbol * sym = func_def->lookup_symbol((*it++)->get_name());
      const char * index = FortranAnalysis::getAttributeValue(sym, "index_attr");
      const char * desc  = FortranAnalysis::getAttributeValue(sym, "descriptor_attr");

      if (index != NULL && desc != NULL) {
         if (num_dims == 1) {
            fprintf(fp, "   int %s = get_desc_idx_1d(%s);\n", index, desc);
         }
         else if (num_dims == 2) {
            fprintf(fp, "   int %s = get_desc_idx_2d(%s);\n", index, desc);
         }
      }
   }
}
