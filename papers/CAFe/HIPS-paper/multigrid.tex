\section{Multigrid Laplacian Implementation}

In this section a one-dimensional solution to Laplace's equation is described using CAFe.
The solution uses multigrid techniques to speedup convergence.

Array allocation, initialization, using Fortran and CAFe contructs as shown above.

\small
\begin{verbatim}
 type(event_type) :: evt
\end{verbatim}
\normalsize

\small
\begin{verbatim}
 do i = 1, nsteps                            1
   call relax (N, V1h[dev], Buf[dev])        &
                    [[dev, EVENT=evt]]       2
   call relax_boundary (N, V1h)              3

   wait event (evt, until_count=i)           4

   V1h(0)[dev] = V1h(0)                      5
   V1h(N)[dev] = V1h(N)                      6

   V1h(  1) = V1h(  1) [dev]                 7
   V1h(N-1) = V1h(N-1) [dev]                 8

   sync all                                  9

   V1h( -1) = V1h(N-1) [left]               10
   V1h(N+1) = V1h(  1) [right]              11
 end do                                     12

 call restrict(N,V1h[dev],V2h[dev]) [[dev]] 13
\end{verbatim}
\normalsize


Once a subimage is obtained, memory on the device can be allocated,
\small
\begin{verbatim}
   if (device /= this_image()) then
      allocate(U[device], HALO_SRC=U)   [[device]]
   end if
\end{verbatim}
\normalsize
There are four points to note regarding this memory allocation: 1. Memory is only allocated if a
subimage has been obtained; 2. The location where memory is allocated is denoted by regular coarray
notation \texttt{U[device]}; 3. The allocated size and halo attribute of the new array are obtained
from the previously allocated local array \texttt{U} via the notation \texttt{HALO\_SRC=U} (using
\texttt{HALO\_SRC} will also initially copy \texttt{U} to the subimage); and finally 4. The
allocation itself is \emph{executed} on the subimage device with the notation \texttt{[[device]]}.

Fortran uses square bracket notation, e.g. \texttt{[image]}, to specify on what process the
memory reference is physically located.  Square brackets are a visual clue to the
programmer that the memory reference may be remote and therefore potentially suffer a
performance penalty.  CAFe extends this by employing double-bracket notation to indicate
possibly \emph{remote subimage execution}.

Note that a transfer of halo memory is necessary after each completion of the do concurrent loop.
This must be done in order for the halo region of a coarray on a given process to be consistent
with the corresponding interior of the coarray on a logically neighboring process.
Finally, memory for the entire array \texttt{U} can be copied from the
subimage device with the statement,
\texttt{U = U[device]}, 
and memory deallocation (not shown) is similar to memory allocation.

