module Main where

import System.Console.GetOpt
import System.Environment ( getArgs )

import Control.Monad ( when, guard )
import Control.Monad.Trans.RWS.Strict
import Control.Monad.IO.Class
import Control.Applicative

import Data.List ( foldl', isSuffixOf )
import Data.Map ( Map )
import qualified Data.Map as M
import Data.Monoid

-- Project specific imports
import ATerm.AbstractSyntax -- ( ATermTable, getATermByIndex1, getATerm )
import ATerm.Utilities hiding (foldl', mapM_, mapM, map, concatMap)
import ATerm.Matching
import ATerm.Pretty
import qualified ATerm.Utilities as U

---------------------------------------------------------------------
-- Command Line options
---------------------------------------------------------------------
data Options = Options
  { optSource :: Maybe FilePath -- ^ Nothing means read from stdin
                                --   otherwise read this file
  }
  deriving (Read, Show, Eq)

options :: [ OptDescr (Options -> Options) ]
options =
  [ Option "s" ["source"]
      (ReqArg (\arg opt -> opt { optSource = Just arg }) "FILE")
      "ATerm file to check"
  ]

defaultOptions :: Options
defaultOptions = Options { optSource = Nothing }

header :: String
header = unlines
  [ "usage: [-s FILE]"
  , "  If no file is given, input is taken from stdin"
  ]

---------------------------------------------------------------------
-- Main program
---------------------------------------------------------------------
main :: IO ()
main = do
  args <- getArgs
  let (flags, _, errors) = getOpt RequireOrder options args
      opts = foldl' (.) id flags defaultOptions
  when (not (null errors)) $ error (concat errors ++ usageInfo header options)
  cs <- removeTrailingDot <$> maybe getContents readFile (optSource opts)
  let aterms = U.readATerm cs
  rs <- exec aterms
  putStrLn "Results: "
  mapM_ print rs
  return ()
  where
  removeTrailingDot s
    | length s >= 2 && ".\n" `isSuffixOf` s = init (init s)
    | otherwise = s

---------------------------------------------------------------------
-- Analysis
---------------------------------------------------------------------
variableTypes :: ATermTable -> [(Variable, Type)]
variableTypes t = do
  exactlyNamed "variable_declaration" t
  l <- getATermFromTable t <$> U.children t
  guard . isList . getATerm $ l
  c <- getATermFromTable l <$> U.children l
  exactlyNamed "initialized_name" c
  annot <- getATermFromTable c <$> U.children c
  exactlyNamed "initialized_name_annotation" annot
  (ty:name:_) <- return $ U.children annot
  Just name'  <- return (extractString (getATermFromTable annot name))
  Just ty'    <- return (extractString (getATermFromTable annot ty))
  return ( name', ty' )
  where
  isList (ShAList {}) = True
  isList _            = False

exprs :: ATermTable -> [ATermTable]
exprs t = do
  exactlyNamed "expr_statement" t
  c <- getATermFromTable t <$> U.children t
  return c

data State = State
  { sConstraints    :: [Constraint]
  , sFreshName      :: Int
  , sVarConstraints :: Map Variable Constraint
  }

initialState :: State
initialState = State
  { sConstraints    = []
  , sFreshName      = 0
  , sVarConstraints = M.empty
  }

modifyConstraints :: (Monad m, Monoid log)
                  => ([Constraint] -> [Constraint]) -> CheckM log State m ()
modifyConstraints f = modify (\s -> s { sConstraints = f (sConstraints s) })

newName :: (Monad m, Monoid log)
        => CheckM log State m Int

newName = do
  s <- get
  put (s { sFreshName = 1 + (sFreshName s) })
  return (sFreshName s)

modifyVarConstraints :: (Monad m, Monoid log)
                     => (Map Variable Constraint -> Map Variable Constraint)
                     -> CheckM log State m ()
modifyVarConstraints f =
  modify (\s -> s { sVarConstraints = f (sVarConstraints s) })

data Constraint
  = CName Int -- ^ Constraints are named by number
  | Constraint :=: Constraint -- ^ Equality constraint generated by:
                              --     (==, !=, <, >, <=, >=),
                              --     (+), (-), and assignment (=)
  | Constraint :+: Constraint -- ^ Sum constraint, generated by mult ops
  | Constraint :-: Constraint -- ^ Difference constraint, generated by division
  | Constraint :*: Constraint -- ^ Product constraint, generated by **
  | Constraint :&: Constraint -- ^ And constraint generated as needed
  deriving (Read, Show, Eq, Ord)

type Variable = String -- Good enough for now
type Type     = String -- Good enough for now

mkVars :: (MonadIO m, Functor m) => CheckM [a] State m ()
mkVars = do
  t <- currentTerm
  let vars  = variableTypes t
  mapM_ mkConstraintsFromVars vars

mkConstraintsFromVars :: (Monad m, Functor m, Monoid log)
                      => (Variable, Type)
                      -> CheckM log State m ()
mkConstraintsFromVars (v,"\"type_float\"") = do
  m <- sVarConstraints <$> get
  case M.lookup v m of
    Nothing -> do
      n <- CName <$> newName
      let m' = M.insert v n m
      modifyVarConstraints (const m')
    Just _  -> return ()
mkConstraintsFromVars _ = return ()

mkConstraints :: (MonadIO m, Monoid log)
              => CheckM log State m ()
mkConstraints = do
  t <- currentTerm
  let es = exprs t
  liftIO $ mapM_ (print . ppATerm) es

mkVarRefExpConstraint :: ATermTable
                      -> Map Variable Constraint
                      -> Either String Constraint
mkVarRefExpConstraint t m = do
  let ns = extractName
  case ns of
    [name] -> case M.lookup name m of
      -- The nothing case happens if the variable is not "type_float"
      -- but is used in a float expression.
      Nothing -> fail "unexpected variable"
      Just x  -> return x
    _ -> fail "bad aterm structure?"
  where
  extractName = do
    exactlyNamed "var_ref_exp" t
    c <- getATermFromTable t <$> children t
    exactlyNamed "var_ref_exp_annotation" c
    let (_ty:name:_) = children c
        Just name'   = extractString (getATermFromTable c name)
    return name'

mkMultOpConstraint :: ATermTable
                   -> Map Variable Constraint
                   -> Either String Constraint
mkMultOpConstraint t m = do
  -- would we ever have a multiply_op with more than 2
  -- children?
  let [c1,c2] = extractChildConstraints
  return (c1 :+: c2)
  where
  extractChildConstraints :: [Constraint]
  extractChildConstraints = do
    exactlyNamed "multiply_op" t
    c <- getATermFromTable t <$> children t
    getConstraints c m

mkEqualityConstraint :: ATermTable
                     -> Map Variable Constraint
                     -> [Constraint]
mkEqualityConstraint _t _m = []

mkAddConstraint :: ATermTable
                -> Map Variable Constraint
                -> [Constraint]
mkAddConstraint _t _m = []

mkSubtractConstraint :: ATermTable
                     -> Map Variable Constraint
                     -> [Constraint]
mkSubtractConstraint _t _m = []

mkMultConstraint :: ATermTable
                 -> Map Variable Constraint
                 -> [Constraint]
mkMultConstraint _t _m = []

getConstraints :: ATermTable
               -> Map Variable Constraint
               -> [Constraint]
getConstraints t m = do
  case getATerm t of
    ShAAppl s is _ -> case s of
      {- == -} "equality_op"         -> mkEqualityConstraint t m
      {- /= -} "not_equal_op"        -> mkEqualityConstraint t m
      {- <  -} "less_than_op"        -> mkEqualityConstraint t m
      {- >  -} "greater_than_op"     -> mkEqualityConstraint t m
      {- <= -} "less_or_equal_op"    -> mkEqualityConstraint t m
      {- >= -} "greater_or_equal_op" -> mkEqualityConstraint t m
      {- +  -} "add_op"              -> mkEqualityConstraint t m
      {- -  -} "subtract_op"         -> mkEqualityConstraint t m
      {- =  -} "assign_op"           -> mkEqualityConstraint t m
      {- *  -} "multiply_op"         -> mkAddConstraint      t m
      {- /  -} "divide_op"           -> mkSubtractConstraint t m
      {- ** -} "exponentiation_op"   -> mkMultConstraint     t m
               _                     -> concatMap
                 (\i -> getConstraints (getATermFromTable t i) m) is
    ShAList   is _ -> concatMap
      (\i -> getConstraints (getATermFromTable t i) m) is
    _              -> [] -- Generate unitless constraint?

exec :: ATermTable -> IO [Constraint]
exec at = do
  (m, _) <- execRWST (do everywhere_ mkVars
                         everywhere_ mkConstraints) at initialState
  return (M.elems (sVarConstraints m) ++ (sConstraints m))
