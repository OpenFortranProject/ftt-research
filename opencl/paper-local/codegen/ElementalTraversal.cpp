#include <rose.h>
#include "ElementalTraversal.hpp"

ElementalTraversal::ElementalTraversal(const char * filename)
   : FortranTraversal(filename)
{
   num_arrays = 0;
   array_list = new char * [1];
   array_list[0] = NULL;

   open(filename);
}

ElementalTraversal::ElementalTraversal(const char * filename, const char * arrays)
   : FortranTraversal(filename)
{
   int i = 0;
   num_arrays = 0;

   if (strncmp(arrays, "-ofp:", 5) == 0) {
      char * str = strdup(&arrays[5]);
      char * chrp = str;

      if (*chrp != '\0') num_arrays = 1;
      while (*chrp != '\0') {
         if (*chrp++ == ' ') num_arrays += 1;
      } 

      array_list = new char * [num_arrays];

      chrp = str;
      array_list[i++] = str;
      while (*chrp != '\0') {
         if (*chrp == ' ') {
            *chrp = '\0';
            array_list[i++] = chrp + 1;
         } 
         chrp += 1;
      } 
   }
   else {
      array_list = new char * [1];
      array_list[0] = NULL;
   }

   open(filename);
}

ElementalTraversal::~ElementalTraversal()
{
   delete [] array_list;
}

void ElementalTraversal::open(const char * filename)
{
   this->fp = fopen(filename, "w");
   if (fp == NULL) {
      printf("ElementalTraversal:: ERROR in opening file %s\n", filename);
   }
   ROSE_ASSERT(fp != NULL);

   fprintf(fp, "/*\n");
   fprintf(fp, " * This kernel is automatically generated by Open Fortran Project tools.\n");
   fprintf(fp, " */\n");
}

void ElementalTraversal::visit(SgNode * node)
{
   switch (node->variantT())
   {
      case V_SgFunctionDeclaration : visit( (SgFunctionDeclaration *) node);  break;
      case V_SgFunctionDefinition  : visit( (SgFunctionDefinition  *) node);  break;
   }
}

void ElementalTraversal::visit(SgFunctionDeclaration * func_decl)
{
   char comma[2] = {0,0};

   std::string func_name = func_decl->get_name();
   std::string filename = func_name + ".f90";
   filename = filename.substr(4,filename.size()-1);
   filename[0] = tolower(filename[0]);

   open(filename.c_str());

   fprintf(fp, "\n");
   fprintf(fp, "subroutine %s_wrapper(", func_name.c_str());

   // parameter list
   //

   SgInitializedNamePtrList & names = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator it = names.begin();

   while (it != names.end()) {
      const char * name = (*it++)->get_name().str();
      fprintf(fp, "%s%s", comma, name);
      comma[0] = ',';
   }

   fprintf(fp, ")\n");
   fprintf(fp, "  implicit none\n");

   // variable decls
   //
   SgFunctionDefinition * func_def = func_decl->get_definition();

   visit(func_def);

   // end subroutine stmt
   //
   fprintf(fp, "end subroutine %s_wrapper\n", func_name.c_str());

   fclose(fp);
   fp = NULL;
}

void ElementalTraversal::visit(SgFunctionDefinition * func_def)
{
   char comma[2] = {0,0};

   SgFunctionDeclaration * func_decl = func_def->get_declaration();
   std::string func_name = func_decl->get_name();

   SgBasicBlock * block = func_def->get_body();
   SgStatementPtrList & stmts = block->get_statements();

   fprintf(fp, "\n");
   fprintf(fp, "__kernel void %s (", func_name.c_str());

   // parameter list
   //

   SgInitializedNamePtrList & names = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator p = names.begin();

   while (p != names.end()) {
      fprintf(fp, "%s\n", comma);
      unparseFuncParam(*p++, func_def);
      comma[0] = ',';
   }

   // add return argument
   unparseFuncParamReturn(func_decl, comma);

   fprintf(fp, ")\n");
   fprintf(fp, "{\n");

   // declare parameters
   //
   SgStatementPtrList::iterator it = stmts.begin();
   while (it != stmts.end()) {
      if (isSgVariableDeclaration(*it)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*it);
         unparseVarDecl(var_decl, false);
      }
      it++;
   }
   fprintf(fp, "\n");

#ifdef NOTME

   // declare local C variables
   //
   it = stmts.begin();
   while (it != stmts.end()) {
      if (isSgVariableDeclaration(*it)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*it);
         unparseVarDecl(var_decl, true);
      }
      it++;
   }
   fprintf(fp, "\n");

   // define local C in variables
   //
   it = stmts.begin();
   while (it != stmts.end()) {
      if (isSgVariableDeclaration(*it)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*it);
         unparseVarDef(var_decl, true);
      }
      it++;
   }
   fprintf(fp, "\n");

   // make call to MPI function
   //
   unparseFunctionCall(func_def);

   // copy C variable to out parameters
   //
   fprintf(fp, "  if (ierror_c == MPI_SUCCESS) then\n");
   it = stmts.begin();
   while (it != stmts.end()) {
      if (isSgVariableDeclaration(*it)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*it);
         unparseParamDef(var_decl);
      }
      it++;
   }
   fprintf(fp, "  end if\n");
   fprintf(fp, "  if (present(ierror)) ierror = ierror_c\n");
#endif

   fprintf(fp, "}\n");
}

void ElementalTraversal::unparseVarDecl(SgVariableDeclaration * var_decl, bool local_decl)
{
   bool declare_ic = false;
   char comma[2] = {0,0};
   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   // make sure we aren't in a type definition, e.g., TYPE :: MPI_Comm
   if (isSgClassDefinition(var_decl->get_parent())) return;

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   // find the base type of the declaration statement
   //
   SgType * type = (*it)->get_typeptr();
   if (isSgArrayType(type)) {
      type = isSgArrayType(type)->get_base_type();
   }

   if (isSgTypeFloat(type)) {
      unparseFloatVarDeclStmt(var_decl, local_decl);
      return;
   }
   else if (isSgTypeInt(type)) {
      unparseIntVarDeclStmt(var_decl, local_decl);
      return;
   }
   else {
      fprintf(fp, "  TYPE(UNKNOWN)==%s", type->class_name().c_str());
      fflush(stdout);
   }

   fflush(stdout);

#ifdef NOTME

   if (!local_decl) unparseOptionalModifier(typemod);
   if (!local_decl) unparseIntentModifier(typemod);
   fprintf(fp, " ::");

   it = vars.begin();
   while (it != vars.end()) {
      std::string name = (*it++)->get_name();
      if (local_decl) name += "_c";
      fprintf(fp, "%s %s", comma, name.c_str());
      comma[0] = ',';
   }
   if (isArrayOfRequests(var_decl) || isArrayOfStatuses(var_decl)) {
      if (local_decl) fprintf(fp, "(count)");
      else            fprintf(fp, "(*)");
      declare_ic = true;
   }
   fprintf(fp, "\n");
   if (declare_ic && local_decl) {
      fprintf(fp, "  integer :: ic\n");
   }
#endif
}

/**
 * Define local "C" variables before calling the MPI function.
 */
void ElementalTraversal::unparseVarDef(SgVariableDeclaration * var_decl, bool local_decl)
{
   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   // make sure we aren't in a type definition, e.g., TYPE :: MPI_Comm
   if (isSgClassDefinition(var_decl->get_parent())) return;

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator ivars = vars.begin();

   SgType * type = (*ivars)->get_typeptr();
   while (ivars != vars.end()) {
      const char * var_name = (*ivars++)->get_name().str();
      if (isChoiceBuffer(var_decl)) continue;
      if (isSgNamedType(type)) {
         // e.g.:  TYPE(MPI_Comm)
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            std::string type_name = isSgNamedType(type)->get_name();
            // Yuk, MPI_Type_f2c should be MPI_Datatype_f2c
            if (type_name == "MPI_Datatype") {
               type_name = "MPI_Type";
            }
            fprintf(fp, "  %s_c = %s_f2c_c(%s%%mpi_val)\n", var_name, type_name.c_str(), var_name);
         }
      }
      else if (isSgTypeInt(type)) {
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = %s\n", var_name, var_name);
         }
      }
      else if (isSgTypeBool(type)) {
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = MERGE(1, 0, %s)\n", var_name, var_name);
         }
      }
      else if (isSgArrayType(type)) {
         if (isArrayOfRequests(var_decl)) {
            fprintf(fp, "  do ic = 1, count\n");
            fprintf(fp, "    array_of_requests_c(ic) = MPI_Request_f2c_c(array_of_requests(ic)%%mpi_val)\n");
            fprintf(fp, "  end do\n");
         }
         else if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = IMPLEMENT ARRAY TYPE for var def\n", var_name, var_name);
         }
      }
      else {
         if (typemod.isIntent_in() || typemod.isIntent_inout()) {
            fprintf(fp, "  %s_c = IMPLEMENT ME class==%s\n", var_name, type->class_name().c_str());
         }
      }
   }
}

/**
 * Define out parameters based on the results of the MPI function call
 */
void ElementalTraversal::unparseParamDef(SgVariableDeclaration * var_decl)
{
   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   // make sure we aren't in a type definition, e.g., TYPE :: MPI_Comm
   if (isSgClassDefinition(var_decl->get_parent())) return;

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator ivars = vars.begin();

   SgType * type = (*ivars)->get_typeptr();
   for (ivars = vars.begin(); ivars != vars.end(); ivars++) {
      const char * var_name  = (*ivars)->get_name().str();
      if (isSgTypeInt(type)) {
         if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            fprintf(fp, "    %s = %s_c\n", var_name, var_name);
         }
      }
      else if (isSgNamedType(type)) {
         // e.g.:  TYPE(MPI_Comm)
         if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            std::string type_name = isSgNamedType(type)->get_name();
            // Yuk, MPI_Type_f2c should be MPI_Datatype_f2c
            if (type_name == "MPI_Datatype") {
               type_name = "MPI_Type";
            }
            fprintf(fp, "    %s%%mpi_val = %s_c2f_c(%s_c)\n", var_name, type_name.c_str(), var_name);
         }
      }
      else if (isSgTypeBool(type)) {
         if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            fprintf(fp, "    %s = MERGE(true, false, %s_c/=0)\n", var_name, var_name);
         }
      }
      else {
         if (isArrayOfRequests(var_decl)) {
            fprintf(fp, "    do ic = 1, count\n");
            fprintf(fp, "      array_of_requests(ic)%%mpi_val = MPI_Request_c2f_c(array_of_requests_c(ic))\n");
            fprintf(fp, "    end do\n");
         }
         else if ((typemod.isIntent_out() || typemod.isIntent_inout()) && !typemod.isOptional()) {
            fprintf(fp, "    %s_c = IMPLEMENT ME class==%s\n", var_name, type->class_name().c_str());
         }
      }
   }
}

void ElementalTraversal::unparseFunctionCall(SgFunctionDefinition * func_def)
{
   char comma[2] = {0,0};
   SgInitializedName * err_var = NULL;

   SgBasicBlock * block = func_def->get_body();
   SgStatementPtrList & stmts = block->get_statements();
   SgFunctionDeclaration * func_decl = func_def->get_declaration();

   // need parameter list to order the local variables and make the function call
   SgInitializedNamePtrList & params = func_decl->get_parameterList()->get_args();
   SgInitializedNamePtrList::iterator iparams = params.begin();

   SgStatementPtrList::iterator istmts;
   for (istmts = stmts.begin(); istmts != stmts.end(); istmts++) {
      if (isSgVariableDeclaration(*istmts)) {
         SgVariableDeclaration * var_decl = isSgVariableDeclaration(*istmts);
         if (isErrorReturn(var_decl)) {
            SgInitializedNamePtrList & vars = var_decl->get_variables();
            SgInitializedNamePtrList::iterator ivars = vars.begin();
            if ((*ivars)->get_name() == "ierror") {
               err_var = (*ivars);
               break;
            }
         }
      }
   }
   ROSE_ASSERT(err_var != NULL);

   const char * func_name = func_decl->get_name().str();
   fprintf(fp, "  %s_c = %s_c(", err_var->get_name().str(), func_name);

   // Unparse variables to function call.  The outer loop is necessary
   // to order the order the local variables to make the function call.

   for (iparams = params.begin(); iparams != params.end(); iparams++) {
      std::string param_name = (*iparams)->get_name();
      istmts = stmts.begin();
      for (istmts = stmts.begin(); istmts != stmts.end(); istmts++) {
         if (isSgVariableDeclaration(*istmts)) {
            SgVariableDeclaration * var_decl = isSgVariableDeclaration(*istmts);
            SgInitializedNamePtrList & vars = var_decl->get_variables();
            SgInitializedNamePtrList::iterator ivars = vars.begin();
            for (ivars = vars.begin(); ivars != vars.end(); ivars++) {
               SgType * type = (*ivars)->get_typeptr();
               if (param_name != (*ivars)->get_name().getString()) continue;
               if (isChoiceBuffer(var_decl)) {
                  fprintf(fp, "%sC_LOC(%s)", comma, (*ivars)->get_name().str());
                  comma[0] = ',';
               }
               else if (isSgNamedType(type) && (isSgNamedType(type)->get_name() == "MPI_Status")) {
                  // use Fortran variable direction, no C equivalent
                  fprintf(fp, "%s%s", comma, (*ivars)->get_name().str());
                  comma[0] = ',';
               }
               else if (!isErrorReturn(var_decl)) {
                  fprintf(fp, "%s%s_c", comma, (*ivars)->get_name().str());
                  comma[0] = ',';
               }
            }
         }
      }
   }
   fprintf(fp, ")\n\n");
}

void ElementalTraversal::unparseFuncParam(SgInitializedName * iname, SgFunctionDefinition * func_def)
{
   bool isArrayType = false;

   SgSymbol * sym = func_def->lookup_symbol(iname->get_name());
   AstAttribute * attr = sym->getAttribute("extended_attr");
   if (attr != NULL) {
      isArrayType = (attr->toString() == "EXTENDED_ARRAY");
   }

   SgType * type = iname->get_typeptr();

   fprintf(fp, "    ");
   if (isArrayType) fprintf(fp, "__global ");

   unparseType(type);
   fprintf(fp, " ");

   if (isArrayType) {
      fprintf(fp, "* ");
   }

   std::string name = iname->get_name();
   fprintf(fp, "%s", name.c_str());
}

/**
 * Unparse the function return parameter
 */
void ElementalTraversal::
     unparseFuncParamReturn(SgFunctionDeclaration * func_decl, const char * comma)
{
   SgType * type = func_decl->get_type()->get_return_type();
   bool isArrayType = isElementalArrayType(func_decl);

   if (isSgTypeVoid(type)) return;

   fprintf(fp, "%s\n", comma);
   if (isArrayType) {
      fprintf(fp, "    __global ");
   }
   unparseType(type);
   fprintf(fp, " ");

   if (isArrayType) {
      fprintf(fp, "* ");
   }
   fprintf(fp, "%s_rtn", func_decl->get_name().str());
}

/**
 * Unparse the list of scalar variables in a variable declaration statement.
 */
void ElementalTraversal::
     unparseVarDeclListForScalars(SgVariableDeclaration * var_decl, bool isLocal)
{
   char comma[2] = {0,0};

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   while (it != vars.end()) {
      SgInitializedName * sginame = (*it++);
      SgType * type = sginame->get_typeptr();

      if (!isSgArrayType(type)) {
         std::string name = sginame->get_name();
         if (isLocal) name += "_c";
         fprintf(fp, "%s %s", comma, name.c_str());
         comma[0] = ',';
      }
   }
}

/**
 * Unparse the list of array variables in a variable declaration statement.
 */
void ElementalTraversal
     ::unparseVarDeclListForArrays(SgVariableDeclaration * var_decl, bool isLocal)
{
   char comma[2] = {0,0};

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   while (it != vars.end()) {
      SgInitializedName * sginame = (*it++);
      SgType * type = sginame->get_typeptr();

      if (isSgArrayType(type)) {
         std::string name = sginame->get_name();
         if (isLocal) name += "_c";
         fprintf(fp, "%s %s(*)", comma, name.c_str());
         comma[0] = ',';
      }
   }
}

/**
 * Unparse a variable declaration statement for integer variables.
 */
void ElementalTraversal::unparseIntVarDeclStmt(SgVariableDeclaration * var_decl, bool local_decl)
{
   bool hasArrayType = false;
   bool hasScalarType = false;

   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   SgType * base_type = (*it)->get_typeptr();
   if (isSgArrayType(base_type)) {
      base_type = isSgArrayType(base_type)->get_base_type();
   }

   // separate scalars and arrays because arrays aren't passed by value
   while (it != vars.end()) {
      SgType * type = (*it++)->get_typeptr();
      if (isSgArrayType(type)) hasArrayType = true;
      else                     hasScalarType = true;
   }

   if (hasScalarType) {
      fprintf(fp, "  integer");
      if (local_decl) fprintf(fp, "(C_INT)");
      if (!local_decl) unparseOptionalModifier(typemod);
      //      if (!local_decl) unparseValueModifier(typemod);
      if (!local_decl) unparseIntentModifier(typemod);
      fprintf(fp, " ::");
      unparseVarDeclListForScalars(var_decl, local_decl);
      fprintf(fp, "\n");
   }

   if (hasArrayType) {
      fprintf(fp, "  integer");
      if (local_decl) fprintf(fp, "(C_INT)");
      if (!local_decl) unparseOptionalModifier(typemod);
      if (!local_decl) unparseIntentModifier(typemod);
      fprintf(fp, " ::");
      unparseVarDeclListForArrays(var_decl, local_decl);
      fprintf(fp, "\n");
   }
}

/**
 * Unparse a variable declaration statement for float variables.
 */
void ElementalTraversal::unparseFloatVarDeclStmt(SgVariableDeclaration * var_decl, bool local_decl)
{
   bool hasArrayType = false;
   bool hasScalarType = false;

   SgDeclarationModifier & mod = var_decl->get_declarationModifier();
   SgTypeModifier & typemod = mod.get_typeModifier();

   SgInitializedNamePtrList & vars = var_decl->get_variables();
   SgInitializedNamePtrList::iterator it = vars.begin();

   SgType * base_type = (*it)->get_typeptr();
   if (isSgArrayType(base_type)) {
      base_type = isSgArrayType(base_type)->get_base_type();
   }

   // separate scalars and arrays because arrays aren't passed by value
   while (it != vars.end()) {
      SgType * type = (*it++)->get_typeptr();
      if (isSgArrayType(type)) hasArrayType = true;
      else                     hasScalarType = true;
   }

   if (hasScalarType) {
      fprintf(fp, "    __global float *");
      unparseVarDeclListForScalars(var_decl, local_decl);
      fprintf(fp, "\n");
   }

   if (hasArrayType) {
      fprintf(fp, "  ERROR:unparseFloatVarDeclStmt: arguments to elemental must be scalar\n");
   }
}

void ElementalTraversal::unparseType(SgType * type)
{
   if (isSgTypeFloat(type)) {
      fprintf(fp, "float");
   }
   else if (isSgTypeInt(type)) {
      fprintf(fp, "int");
   }
   else {
      fprintf(fp, "UNKNOWN TYPE");
   }

   if (isSgNamedType(type)) {
      fprintf(fp, "  NAMED_TYPE is \n");
   }

}

bool ElementalTraversal::isElementalArrayType(SgInitializedName * iname)
{
   for (int i = 0; i < num_arrays; i++) {
      if (strcmp(iname->get_name().str(), array_list[i]) == 0) {
         return true;
      }
   }
   return false;
}

bool ElementalTraversal::isElementalArrayType(SgFunctionDeclaration * func_decl)
{
   return true;
}
